## 第四章 `x86`汇编速成

### 基本分析技术之间的区别

- 基本静态分析:从外部观察恶意软件

- 基本动态分析:只观察特定情形下的恶意软件行为

- 反汇编技术:分析恶意软件的代码以分析出其具体行为

### 抽象层次及其划分

- `硬件`:即数字电路(异或门,与门,或门,非门等),不易被软件操控
- `微码`(固件):只能在为其设计的特定硬件上工作,在恶意软件分析一般不重要
- `机器码`(操作码):直接指定处理器行为,在高级语言编写的程序编译时生成,机器可读
- `低级语言`:例如汇编语言,是可读版本的处理器指令集,可使用反汇编器生成.这是当无源代码时,可从恶意软件可靠恢复出来的最高级语言,不同的汇编语言基于不同的处理器和指令集
- `高级语言`:如`C++`,`C`等语言,可被编译器转换为机器码
- `解释语言`:如`Java`,`C#`,`Perl`,`.NET`,`Python`等语言,代码不可被编译为机器码,只能转换为字节码
  - `字节码`:是一种中间表示形式,独立于硬件和操作系统,在解释器中执行
  - `解释器`:将字节码在运行时动态的翻译成机器码的工具,例如`Java`虚拟机

### 恶意软件的逆向工程

#### 逆向工程的原因

- 在磁盘中恶意软件以二进制机器码形式存在
- 可用反汇编器转换为汇编语言(常见工具`IDA Pro`)

#### 汇编语言的分类

> 不同的汇编语言基于不同的处理器和指令集

- 基于`x86`32位`intel`处理器(最常见,恶意程序针对的主要平台)

- 基于`x64`64位`intel`处理器(`x64`机器一般兼容`x86`程序)
- 基于`SPARC`、`PowerPC`机器
- 基于`MIPS`指令集、`ARM`指令集等

### `x86`架构分析

#### `CPU`部件组成

- `控制单元`:使用指令指针寄存器从`RAM`(内存)取指令

- `寄存器堆`:`CPU`内的数据存储器,比`RAM`(内存)更快

- `ALU`:算术逻辑单元,执行指令并将结果放入寄存器堆或`RAM`(内存)

#### 内存中的程序

- 最低地址:栈
  - 存储函数的内部变量和参数
  - 帮助程序跳转
- 次低地址:堆
  - 程序在此申请新数据空间和释放
  - 动态的,在程序执行时频繁改变
- 次高地址:代码段
  - 包含程序指令,控制处理器运行
- 最高地址:数据段
  - 在软件装载时在`RAM`(内存)中
  - 静态的,在程序运行时不能改变
  - 全局的,程序任一部分都可访问

#### 数据和指令格式

- 指令:助记符与后跟的操作数的组合

- 数据的端序:分为大端序和小端序
  - 大端序:高位(前位)字节存入低地址(网络数据常用)
  - 小端序:高位(前位)字节存入高地址(`x86`程序常用)

- `IP`地址格式
  - 数字和`.`隔开的格式
  - 十六进制格式

- 操作数格式
  - 立即数(立即数是操作数)
  - 内存地址(指定地址的内存的值是操作数),使用`[]`
  - 寄存器名(指定寄存器中的值是操作数的地址,指定地址的内存的值是操作数),使用`[]`
  - 段基址/寄存器名+偏移量(段基址/指定寄存器中的值与偏移量运算后的指定地址的内存的值是操作数),使用`[]`

#### 寄存器分类与特性

- 通用寄存器:`CPU`执行时使用
  - `eax`/`ebx`/`ecx`/`edx`/`ebp`/`esp`/`esi`/`edi`(32位)
  - `al`/`ah`(低16位/高16位)
  - 主要存储数据
  - 特定指令使用指定的寄存器(乘使用`eax`,除使用`edx`,存返回值使用`eax`)
  - 特定功能值存于指定寄存器(栈顶地址存于`esp`,栈底地址存于`ebp`)
- 段寄存器:用于定位内存各个节
- 状态寄存器:又称`eflags`寄存器,置`1`称置位,置`0`称复位,用于决策,含有以下部分
  - `zf`(零标志):结果为`0`时置位
  - `cf`(进位标志):最高位需进位/退位时置位
  - `sf`(符号标志):运算结果为负数时置位
  - `tf`(追踪标志):置位时处理器只能同时执行一条指令
  - `of`(溢出标志):运算结果溢出时置位
- 指令指针寄存器:存储下一指令的地址
  - 如果存入错误值,`CPU`会取到不合法指令并崩溃
  - 是缓冲区溢出漏洞的主要覆盖目标

### 简单指令

#### 基本指令

##### `mov`指令

- 格式
  - `mov` 目标数,源数(`PE`文件格式)
  - `mov` 源数,目标数(`linux`格式)
- 功能:源数的值赋给目标数

##### `lea`指令

- 格式:`lea` 目标数,源数(=`mov` 目标数,源数作为地址时指定的值)

- 功能:源数的值所在的地址赋给目标数

##### 栈指令

- 栈的特点:用于存储函数,内部变量,以及流控制,是先进后出的,向低地址拓展

- 格式:`push` 源数/`pop` 目标数
- 功能:将源数的值压栈/将出栈的值赋给目标数

#### 算数指令

- 指令名:`sub`/`add`/`mul`/`div`/`inc`(自增)/`dec`(自减)
- 格式:`指令名` 目标数,源数
- 功能:源数和目标数运算的结果赋给目标数

#### 其他指令

##### `nop`指令

- 空指令,机器码为`0x90`
- 功能:常用作`NOP`雪橇,填充空内存区间以自动滑到下一个有用指令
  - 允许攻击者在运行代码时进行不精确的指令跳转

##### `call`指令

- 格式:`call` 目标地址
- 功能:跳转到指定地址,调用函数

##### `ret`指令

- 格式:`ret`
- 功能:结束函数调用,跳回`call`指令位置

##### `test`指令

- 格式:`test` 源数1,源数2
- 功能:操作数做逻辑与运算,结果为零将`zf`置位

##### `cmp`指令

- 格式:`cmp` 源数1,源数2
- 功能:操作数做算数减运算,结果为零将`zf`置位

##### `rep`系列指令

- 指令名:`REP`(重复)、`REPE`(相等时重复)、`REPNE`(不相等时重复)、`REPZ`(为零时重复)及`REPNZ`(不为零时重复)

- 结束重复条件:`REP`(`ecx=0`)、`REPE`/`REPZ`(`ecx=0`或`zf=0`)、`REPNE`/`REPNZ`(`ecx=0`或`zf=1`)

#### 跳转指令

##### `jz`/`jnz`指令

- 格式:`jz` 地址/`jnz` 地址
- 功能:在`zf`置位/复位时跳转到指定地址

##### `jg`/`jl`/`jge`/`jle`指令

- 格式:`jg` 地址/`jl` 地址/`jge` 地址/`jle` 地址
- 功能:在大于/小于/大于等于/小于等于时跳转到指定地址