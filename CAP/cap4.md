## 第四章 `x86`汇编速成

### 基本分析技术之间的区别

- 基本静态分析:从外部观察恶意软件

- 基本动态分析:只观察特定情形下的恶意软件行为

- 反汇编技术:分析恶意软件的代码以分析出其具体行为

### 抽象层次及其划分

- `硬件`:由数字电路(异或门,与门,或门,非门等)构成,不易被软件操控
- `微指令`(固件):只能在为其设计的特定硬件上工作,在恶意软件分析一般不重要
- `机器码`(操作码):由数个微指令实现,指定处理器行为,在高级语言编写的程序编译时生成,机器可读
- `低级语言`:主要是汇编语言,是可读版本的处理器指令集,可使用反汇编器生成.这是当无源代码时,可从恶意软件可靠恢复出来的最高级语言,不同的汇编语言基于不同的处理器和指令集
- `高级语言`:如`C++`,`C`等语言,可被编译器转换为机器码
- `解释语言`:如`Java`,`C#`,`Perl`,`.NET`,`Python`等语言,代码不可被编译为机器码,只能转换为字节码
  - `字节码`:是一种中间表示形式,独立于硬件和操作系统,在解释器中执行
  - `解释器`:将字节码在运行时动态的翻译成机器码的工具,例如`Java`虚拟机

### 恶意软件的逆向工程

#### 逆向工程的原因

- 在磁盘中恶意软件以二进制机器码形式存在
- 可用反汇编器转换为汇编语言(常见工具`IDA Pro`)

#### 汇编语言的分类

> 汇编语言是一类语言,不同的汇编语言基于不同的处理器和指令集

- 基于`x86`32位`intel`处理器(最常见,恶意程序针对的主要平台)

- 基于`x64`64位`intel`处理器(`x64`机器一般兼容`x86`程序)
- 基于`SPARC`、`PowerPC`机器
- 基于`MIPS`指令集、`ARM`指令集等

### `x86`架构分析

#### `CPU`(中央处理单元)部件组成

- `控制单元`:使用指令指针寄存器从`RAM`(内存)取指令

- `寄存器堆`:`CPU`内的数据存储器,比`RAM`(内存)更快

- `ALU`:算术逻辑单元,执行指令并将结果放入寄存器堆或`RAM`(内存)

#### 内存中的程序

- 最低地址:栈
  - 存储函数的内部变量和参数,是先进后出的,自高地址向低地址拓展
  - 帮助程序跳转
- 次低地址:堆
  - 程序在此申请新数据空间和释放
  - 动态的,在程序执行时频繁改变
- 次高地址:代码段
  - 包含程序指令,控制处理器运行
- 最高地址:数据段
  - 在软件装载时在`RAM`(内存)中
  - 静态的,在程序运行时不能改变
  - 全局的,程序任一部分都可访问

#### 数据和指令格式

- 指令:助记符与后跟的操作数的组合

- 数据的端序:分为大端序和小端序
  - 大端序:高位(前位)字节存入低地址(网络数据常用)
  - 小端序:高位(前位)字节存入高地址(`x86`程序常用)

- `IP`地址格式
  - 数字和`.`隔开的格式
  - 十六进制格式

- 操作数格式
  - 立即数:
    - 立即数是操作数
    - 不使用`[]`
  - 数值内存地址:
    - 指定地址的内存的值是操作数
    - 使用`[]`
  - 寄存器名:
    - 指定寄存器内的数是操作数
    - 不使用`[]`
  - 寄存器名:
    - 指定寄存器中的值是操作数的地址,指定地址的内存的值是操作数
    - 使用`[]`
  - 复合内存地址:
    - 形式为段基址/寄存器名+偏移量
    - 段基址/指定寄存器中的值与偏移量运算后的指定地址的内存的值是操作数
    - 使用`[]`

#### 寄存器分类与使用约定

- 通用寄存器:`CPU`执行时使用
  - `eax`/`ebx`/`ecx`/`edx`/`ebp`/`esp`/`esi`/`edi`(32位)
  - `al`/`ah`(低16位/高16位)
  - 主要存储数据
  - 特定指令使用指定的寄存器(乘使用`eax`,除使用`edx`,存返回值使用`eax`)
  - 特定功能值存于指定寄存器(栈顶地址存于`esp`,栈底地址存于`ebp`)
- 段寄存器:用于定位内存各个节
- 状态寄存器:又称`eflags`寄存器,置`1`称置位,置`0`称复位,用于决策,含有以下部分
  - `zf`(零标志):结果为`0`时置位
  - `cf`(进位标志):最高位需进位/退位时置位
  - `sf`(符号标志):运算结果为负数时置位
  - `tf`(追踪标志):用于调试,置位时处理器只能同时执行一条指令
  - `of`(溢出标志):运算结果溢出时置位
  - `df`(方向标志):用于决定循环时是自增还是自减
- 指令指针寄存器:存储下一指令的地址
  - 如果存入错误值,`CPU`会取到不合法指令并崩溃
  - 是缓冲区溢出漏洞的主要覆盖目标

#### 函数调用流程实例

- 使用`push`指令将参数压栈
- 使用`call`指令跳到新函数入口
- 根据函数序言分配栈中的局部变量的空间,将`ebp`压栈
- 函数运作
- 根据函数结语恢复栈,更新`esp`以释放局部变量,弹栈恢复`ebp`
- 使用`ret`指令返回原调用位置继续执行
- 调整栈,移除无用参数

#### `x86`简单指令

##### `mov`指令

- 格式
  - `mov` 目标数,源数(`intel汇编`格式)
  - `mov` 源数,目标数(`linux`格式)
- 功能:源数的值赋给目标数
- 注意:当源数为内存地址时,是非法指令

##### `lea`指令

- 格式:`lea` 目标数,源数(=`mov` 目标数,源数作为地址时指定的值)
- 功能:源数的值所在的地址赋给目标数
- 注意:`lea`意为载入有效地址,`load effective address`

##### 栈指令

- 栈的特点:用于存储函数,内部变量,以及流控制
- 格式:`push` 源数/`pop` 目标数
- 功能:将源数的值压栈,或是将出栈的值赋给目标数
- 注意:
  - `push`指令使`esp`的值自减`4`,`pop`指令使`esp`的值自增`4`
  - 还可使用源数为`ss:[esp]`的`mov`指令直接访问栈顶而不改变栈的结构
  - `push`/`pop`指令可后缀`a`/`ad`,用于将`16位`/`32位`寄存器压栈,但编译器很少使用,一般出现在人工写的汇编代码中

##### 算术指令

- 指令名:`sub`/`add`/`mul`/`div`/`inc`(自增)/`dec`(自减)
- 格式:`指令名` 目标数,源数
- 功能:源数和目标数运算的结果赋给目标数

##### `nop`指令

- 空指令,机器码为`0x90`
- 功能:常用作`NOP雪橇`,填充空内存区间以自动滑到下一个有用指令
  - 允许攻击者在运行代码时进行不精确的指令跳转
- 注意:实际上是指令`xchg eax,eax`的伪名,实际上是无运算

##### `call`指令

- 格式:`call` 目标地址
- 功能:`eip`寄存器值压栈,`eip`的值更新为目标地址

##### `ret`指令

- 格式:`ret`
- 功能:将保存的原`eip`的值弹栈,重新赋给`eip`

##### `leave`指令

- 格式:`leave`
- 功能:将`ebp`当前值赋给`esp`,再弹栈恢复`ebp`,用于函数的结语部分

##### `test`指令

- 格式:`test` 源数1,源数2
- 功能:操作数做逻辑与运算,结果为零将`zf`置位
- 注意:取源数1=源数2时,常用于检查源数1/源数2是否为`NULL`值(即`0`)

##### `cmp`指令

- 格式:`cmp` 源数1,源数2
- 功能:操作数做算数减运算,结果为零将`zf`置位,源数2大于源数1时将`cf`置位

##### `rep`系列指令

- 格式:`指令名` `数据缓冲区指令`

- 指令名:`REP`(重复)、`REPE`(相等时重复)、`REPNE`(不相等时重复)、`REPZ`(为零时重复)及`REPNZ`(不为零时重复)
- 数据缓冲区指令:
  - `movsb`
    - 循环执行`mov`指令,将`esi`作为地址指向的字节存入`edi`作为地址指向字节作为源数和目标数
    - `df`若置位,`esi`与`edi`自减,否则自增
    - 类似`memcpy`函数,常用`rep movsb`
  - `cmpsb`
    - 循环执行`cmp`指令,将`esi`作为地址指向字节与`edi`作为地址指向字节作为源数1和源数2
    - `df`若置位,`esi`与`edi`自减,否则自增
    - 类似`memcmp`函数,常用`repe cmpsb`
  - `scasb`
    - 循环执行`cmp`指令,将`esi`作为地址指向字节与`al`的值作为源数1和源数2
    - 当在`esi`指向的字节找到`al`所代表的值时,将地址存入`esi`
    - 常用`repne scasb`
  - `stosb`
    - 循环执行`mov`指令,将指定字节存入`edi`作为地址指向的字节
    - 类似`memset`函数,用于初始化内存区域,常用`rep stosb`
- 功能:
  - 根据判断累加器`ecx`和零标志`zf`的值,进行有限次循环
  - 结束重复条件:`REP`(`ecx=0`)、`REPE`/`REPZ`(`ecx=0`或`zf=0`)、`REPNE`/`REPNZ`(`ecx=0`或`zf=1`)

##### `jz`/`jnz`指令

- 格式:`jz` 地址/`jnz` 地址
- 功能:在`zf`置位/复位时跳转到指定地址
- 归类为`jcc`指令,即条件跳转指令

##### `jg`/`jl`/`jge`/`jle`指令

- 格式:`jg` 地址/`jl` 地址/`jge` 地址/`jle` 地址
- 功能:在大于/小于/大于等于/小于等于时跳转到指定地址
- 无符号形式为`ja`/`jb`/`jae`/`jbe`
- 归类为`jcc`指令,即条件跳转指令

##### `jo`/`js`/`jecxz`指令

- 格式:`jo` 地址/`js` 地址/`jecxz` 地址
- 功能:在`of`置位/`sf`置位/`ecx=0`时跳转
- 归类为`jcc`指令,即条件跳转指令